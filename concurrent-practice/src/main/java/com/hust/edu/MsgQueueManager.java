package com.hust.edu;import java.util.ArrayList;import java.util.List;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedTransferQueue;/** * 总消息队列管理 * 多生产者多消费者模型 * @author tengfei.fangtf */public class MsgQueueManager implements IMsgQueue {    private static MsgQueueManager msgQueueManager;    private List<BlockingQueue> subQueues;    public static class MsgQueueFactory {        public static MsgQueueManager getMessageQueue(){            return getInstance();        }    }    public static MsgQueueManager getInstance(){        if(msgQueueManager==null){            synchronized (MsgQueueManager.class){                if(msgQueueManager==null)                    msgQueueManager=new MsgQueueManager();            }        }        return msgQueueManager;    }    /**     * 消息总队列     */    public final BlockingQueue<Message> messageQueue;    private MsgQueueManager() {        messageQueue = new LinkedTransferQueue<Message>();        subQueues = new ArrayList<>(10);        for (int i = 0; i < 10; i++) {            subQueues.add(new LinkedTransferQueue<Message>());        }    }    public void put(Message msg) {        try {            messageQueue.put(msg);        } catch (InterruptedException e) {            Thread.currentThread().interrupt();        }    }    public Message take() {        try {            return messageQueue.take();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();        }        return null;    }    /**     * 均衡的获取一个子队列     * @return     */    public BlockingQueue<Message> getSubQueue(){        int errorCount=0;        for(;;){            if(subQueues.isEmpty()){                return null;            }            int index= (int) ((System.nanoTime()) % subQueues.size());            try {                return subQueues.get(index);            }catch (Exception e){                System.out.println("获取队列出现错误");                if((++errorCount)<3)                    continue;            }        }    }    private static class DispatchMessageTask implements Runnable{        @Override        public void run() {            BlockingQueue<Message> subQueue;            for (;;){                //如果没有数据，就阻塞在这里                Message msg = MsgQueueFactory.getMessageQueue().take();                //如果为null，则表示没有session机器连接上来                //需要等待，知道有session机器连接上来                while ((subQueue=getInstance().getSubQueue())==null){                    try {                        Thread.sleep(1000);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                //把小消息放入小队列中                try {                    subQueue.put(msg);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }}